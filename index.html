<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <title>Space Shooter: Canvas Text</title>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; user-select: none; }
    
    #hud {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10;
    }
    #q-box {
      position: absolute; top: 30px; width: 100%; text-align: center;
    }
    .q-text {
      background: rgba(0, 0, 0, 0.8);
      border: 3px solid #00ff00;
      border-radius: 15px;
      padding: 15px 40px;
      color: #fff;
      font-family: Arial, sans-serif;
      font-size: 32px;
      font-weight: bold;
      display: inline-block;
      box-shadow: 0 0 15px #00ff00;
    }
    #crosshair {
      position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border: 2px solid white;
    }
    .crosshair-active {
        transform: translate(-50%, -50%) scale(2.5) !important;
        background: rgba(0, 255, 0, 0.5) !important;
        border-color: #00ff00 !important;
    }
    .hint {
        position: absolute; bottom: 10%; width: 100%; text-align: center; 
        color: white; font-family: sans-serif; opacity: 0.8; font-weight: bold;
    }
    #win-screen {
      display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: black; flex-direction: column; justify-content: center; align-items: center;
      color: lime; font-family: monospace; pointer-events: auto;
    }
  </style>

  <script>
    // --- ВАШИ УРОВНИ (РУССКИЙ ТЕКСТ ТЕПЕРЬ БУДЕТ РАБОТАТЬ) ---
    const levels = [
      { q: "Столица России?", a: [ {t:"Москва", c:true}, {t:"Париж", c:false}, {t:"Омск", c:false} ] },
      { q: "2 + 2 = ?", a: [ {t:"4", c:true}, {t:"5", c:false}, {t:"10", c:false} ] },
      { q: "Земля плоская?", a: [ {t:"Нет", c:true}, {t:"Да", c:false}, {t:"Возможно", c:false} ] }
    ];

    // --- ЗВУК ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      
      if (type === 'shoot') { 
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
      } else if (type === 'hit') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.4);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.4);
        osc.start(now); osc.stop(now + 0.4);
      }
    }

    // --- НОВЫЙ КОМПОНЕНТ: РИСУЕМ ТЕКСТ КАК КАРТИНКУ ---
    // Это решает проблему с шрифтами и исчезновением
    AFRAME.registerComponent('canvas-label', {
      schema: { 
        text: {type: 'string', default: ''},
        color: {type: 'string', default: 'yellow'}
      },
      init: function() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = 512;
        this.canvas.height = 256;
        this.ctx = this.canvas.getContext('2d');
        this.texture = new THREE.CanvasTexture(this.canvas);
        
        // Применяем текстуру к материалу объекта
        // Ждем загрузки модели или применяем сразу если это примитив
        this.el.addEventListener('loaded', () => {
            const mesh = this.el.getObject3D('mesh');
            if (mesh) {
                mesh.material.map = this.texture;
                mesh.material.transparent = true;
                // Важно: material.map перезаписывает цвет, поэтому ставим белый базовый
                mesh.material.color.setHex(0xffffff); 
            }
        });
        
        // Если это a-plane, mesh доступен сразу
        if (this.el.getObject3D('mesh')) {
             this.el.getObject3D('mesh').material.map = this.texture;
        }

        this.update();
      },
      update: function() {
        const ctx = this.ctx;
        const w = 512;
        const h = 256;
        
        // 1. Рисуем черный фон
        ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
        ctx.fillRect(0, 0, w, h);
        
        // 2. Рисуем рамку
        ctx.strokeStyle = this.data.color === 'yellow' ? '#FFFF00' : '#00FFFF';
        ctx.lineWidth = 15;
        ctx.strokeRect(0, 0, w, h);

        // 3. Рисуем Текст (Используем стандартный шрифт браузера Arial)
        ctx.fillStyle = this.data.color === 'yellow' ? '#FFFF00' : '#00FFFF';
        ctx.font = "bold 80px Arial"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.data.text, w/2, h/2);
        
        // Обновляем текстуру в 3D мире
        this.texture.needsUpdate = true;
      }
    });

    // --- ДВИЖЕНИЕ ---
    AFRAME.registerComponent('ufo-movement', {
      schema: { offset: {default: 0}, speed: {default: 1} },
      init: function() { this.angle = this.data.offset; },
      tick: function(time, timeDelta) {
        if (!this.el.object3D.visible) return;
        this.angle += 0.0003 * this.data.speed * timeDelta;
        const r = 9; 
        const x = Math.cos(this.angle) * r;
        const z = Math.sin(this.angle) * r;
        const y = Math.sin(time * 0.001 + this.data.offset) * 2 + 3;
        this.el.setAttribute('position', {x, y, z});
      }
    });

    // --- МЕНЕДЖЕР ИГРЫ ---
    AFRAME.registerComponent('game-manager', {
      init: function () {
        this.levelIdx = 0;
        this.container = document.getElementById('ufo-container');
        this.qText = document.querySelector('.q-text');
        this.weapon = document.getElementById('weapon');
        this.laser = document.getElementById('laser');

        this.createStars();
        this.loadLevel(0);
        document.addEventListener('mousedown', () => this.fireVisuals());
      },

      fireVisuals: function() {
        playSound('shoot');
        this.weapon.setAttribute('animation', 'property: position; from: 0.5 -0.4 -0.5; to: 0.5 -0.4 -0.4; dur: 50; dir: alternate; loop: 2');
        this.laser.setAttribute('visible', true);
        setTimeout(() => this.laser.setAttribute('visible', false), 80);
      },

      onHit: function(isCorrect, parentEl) {
        if (isCorrect) {
           playSound('hit');
           this.createExplosion(parentEl.getAttribute('position'));
           parentEl.parentNode.removeChild(parentEl);
           setTimeout(() => {
               this.levelIdx++;
               this.loadLevel(this.levelIdx);
           }, 800);
        } else {
           // Ошибка - красная вспышка на ТАБЛИЧКЕ
           // Мы меняем компонент canvas-label, чтобы перерисовать рамку в красный
           const label = parentEl.querySelector('.answer-label');
           label.setAttribute('canvas-label', 'color: red; text: НЕВЕРНО');
           setTimeout(() => {
               // Возвращаем текст как был (нам нужно достать его из levels, но для простоты просто вернем желтый)
               // В идеале тут надо хранить исходный текст, но для эффекта достаточно сбросить цвет
               const originalText = parentEl.getAttribute('data-text'); 
               label.setAttribute('canvas-label', `color: yellow; text: ${originalText}`);
           }, 500);
        }
      },

      createExplosion: function(pos) {
          for(let i=0; i<15; i++) {
              const p = document.createElement('a-sphere');
              p.setAttribute('radius', 0.2);
              p.setAttribute('color', 'orange');
              p.setAttribute('position', pos);
              const dest = `${pos.x + (Math.random()-0.5)*5} ${pos.y + (Math.random()-0.5)*5} ${pos.z + (Math.random()-0.5)*5}`;
              p.setAttribute('animation', `property: position; to: ${dest}; dur: 700; easing: easeOutQuad`);
              p.setAttribute('animation__fade', `property: opacity; to: 0; dur: 700`);
              this.container.appendChild(p);
          }
      },

      loadLevel: function(idx) {
        if (idx >= levels.length) {
            document.getElementById('win-screen').style.display = 'flex';
            document.exitPointerLock();
            return;
        }
        const data = levels[idx];
        this.qText.innerText = data.q;
        this.container.innerHTML = '';

        data.a.forEach((ans, i) => {
            const el = document.createElement('a-entity');
            el.setAttribute('look-at', '[camera]'); 
            el.setAttribute('ufo-movement', `offset: ${i * 2}; speed: ${0.8 + Math.random() * 0.5}`);
            el.setAttribute('data-text', ans.t); // Сохраняем текст для возврата после ошибки

            // 1. ХИТБОКС (Невидимый пузырь)
            const hitbox = document.createElement('a-sphere');
            hitbox.setAttribute('class', 'clickable');
            hitbox.setAttribute('radius', '3.5');
            hitbox.setAttribute('material', 'opacity: 0; transparent: true; side: double');
            
            hitbox.addEventListener('click', () => this.onHit(ans.c, el));
            hitbox.addEventListener('mouseenter', () => document.getElementById('crosshair').classList.add('crosshair-active'));
            hitbox.addEventListener('mouseleave', () => document.getElementById('crosshair').classList.remove('crosshair-active'));
            el.appendChild(hitbox);

            // 2. МОДЕЛЬ НЛО
            const visual = document.createElement('a-entity');
            visual.innerHTML = `
                <a-cone radius-bottom="1.5" radius-top="0.5" height="0.5" color="#555"></a-cone>
                <a-ring radius-inner="1.5" radius-outer="1.8" color="${ans.c ? '#00ffff' : '#ff00ff'}" rotation="-90 0 0" material="side: double"></a-ring>
                <a-sphere position="0 0.3 0" radius="0.8" color="#333" opacity="0.9"></a-sphere>
            `;
            visual.setAttribute('animation', 'property: rotation; to: 0 360 0; loop: true; dur: 3000; easing: linear');
            el.appendChild(visual);

            // =========================================================
            // 3. ОТВЕТ (НОВЫЙ ПОДХОД - CANVAS LABEL)
            // =========================================================
            // Мы используем простую плоскость, на которую JS рисует текст
            const label = document.createElement('a-plane');
            label.setAttribute('class', 'answer-label');
            label.setAttribute('position', '0 3 0');
            label.setAttribute('width', '5');
            label.setAttribute('height', '2.5');
            // Вот здесь происходит магия отрисовки:
            label.setAttribute('canvas-label', `text: ${ans.t}; color: yellow`);
            label.setAttribute('material', 'transparent: true; side: double'); // Важно для прозрачности фона канваса
            
            el.appendChild(label);
            this.container.appendChild(el);
        });
      },

      createStars: function() {
          const s = document.getElementById('stars');
          for(let i=0; i<400; i++) {
              const star = document.createElement('a-sphere');
              star.setAttribute('position', `${(Math.random()-0.5)*100} ${(Math.random()-0.5)*100} ${(Math.random()-0.5)*100}`);
              star.setAttribute('radius', Math.random()*0.2);
              star.setAttribute('color', '#ffffff');
              star.setAttribute('shader', 'flat');
              s.appendChild(star);
          }
      }
    });
  </script>
</head>
<body>

  <div id="hud">
    <div id="q-box"><div class="q-text">Загрузка...</div></div>
    <div id="crosshair"></div>
    <div class="hint">НАЖМИ НА ЭКРАН! (Русский текст теперь работает)</div>
    <div id="win-screen">
      <h1>ПОБЕДА!</h1>
      <button onclick="location.reload()" style="padding:20px; font-size:24px; cursor:pointer;">ИГРАТЬ СНОВА</button>
    </div>
  </div>

  <a-scene background="color: #02020a">
    <a-entity game-manager></a-entity>
    <a-entity id="stars"></a-entity>

    <a-camera look-controls="pointerLockEnabled: true">
        <a-entity id="weapon" position="0.5 -0.4 -0.5">
            <a-box width="0.1" height="0.1" depth="0.5" color="#444"></a-box>
            <a-cylinder id="laser" visible="false" position="0 0 -10" rotation="90 0 0" radius="0.03" height="20" color="#00ffff" opacity="0.8"></a-cylinder>
        </a-entity>
        <a-cursor fuse="false" raycaster="objects: .clickable; far: 100" position="0 0 -1" opacity="0"></a-cursor>
    </a-camera>

    <a-entity id="ufo-container"></a-entity>
    <a-light type="ambient" color="#FFF"></a-light>
    <a-light type="directional" intensity="0.8" position="-1 2 1"></a-light>
  </a-scene>
</body>
</html>
